# an array with unspecified size and all elements equal to one
struct AllOneTensor; end
Base.getindex(::AllOneTensor, idx...) = 1
Base.size(::AllOneTensor, i::Integer) = 1
Base.axes(::AllOneTensor, i::Integer) = 1:1

# compute the kronecker product only over needed indices
kron2() = AllOneTensor()
function kron2(A₁::Array{F,4}) where F
    @cast _[m₁, n₁, xᵢ, x₁] := A₁[m₁, n₁, x₁, xᵢ]
end
function kron2(A₁::Array{F,4}, A₂::Array{F,4}) where F
    # this is in case A₂ has a wider range for xᵢ.
    # that only happens when A₂ has the same value no matter xᵢ, so we might
    #  as well truncate it
    q = size(A₁)[4]
    A₂ = A₂[:,:,:,1:q]
    @cast _[(m₁, m₂), (n₁, n₂), xᵢ, x₁, x₂] := A₁[m₁, n₁, x₁, xᵢ] * 
        A₂[m₂, n₂, x₂, xᵢ]
end
function kron2(A₁::Array{F,4}, A₂::Array{F,4}, A₃::Array{F,4}) where F
    @cast _[(m₁, m₂, m₃), (n₁, n₂, n₃), xᵢ, x₁, x₂, x₃] := 
        A₁[m₁, n₁, x₁, xᵢ] * A₂[m₂, n₂, x₂, xᵢ] * A₃[m₃, n₃, x₃, xᵢ]
end

# SAMPLING
# sample an index `i` of `w` with probability prop to `w[i]`
# copied from StatsBase but avoids creating a `Weight` object
function sample_noalloc(rng::AbstractRNG, w::AbstractVector) 
    t = rand(rng) * sum(w)
    n = length(w)
    i = 1
    cw = w[1]
    while cw < t && i < n
        i += 1
        @inbounds cw += w[i]
    end
    return i
end
sample_noalloc(w::AbstractVector) = sample_noalloc(GLOBAL_RNG, w)


function cavity!(dest, source, op, init)
    @assert length(dest) == length(source)
    isempty(source) && return init
    if length(source) == 1
        dest[begin] = init 
        return op(first(source), init)
    end
    Iterators.accumulate!(op, dest, source)
    full = op(dest[end], init)
    right = init
    for (i,s)=zip(lastindex(dest):-1:firstindex(dest)+1,Iterators.reverse(source))
        dest[i] = op(dest[i-1], right);
        right = op(s, right);
    end
    dest[begin] = right
    full
end

cavity(source, op, init) = cavity!([init for x in source], source, op, init)